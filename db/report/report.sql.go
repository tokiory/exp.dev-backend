// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: report.sql

package report

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createReport = `-- name: CreateReport :one
INSERT INTO reports (id)
VALUES (gen_random_uuid())
RETURNING id
`

func (q *Queries) CreateReport(ctx context.Context) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createReport)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createReportPerson = `-- name: CreateReportPerson :exec
INSERT INTO report_persons (
  report_id,
  name,
  surname,
  patronymic,
  telegram,
  email
) VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateReportPersonParams struct {
	ReportID   pgtype.UUID
	Name       string
	Surname    string
	Patronymic pgtype.Text
	Telegram   string
	Email      string
}

func (q *Queries) CreateReportPerson(ctx context.Context, arg CreateReportPersonParams) error {
	_, err := q.db.Exec(ctx, createReportPerson,
		arg.ReportID,
		arg.Name,
		arg.Surname,
		arg.Patronymic,
		arg.Telegram,
		arg.Email,
	)
	return err
}

const createReportSkills = `-- name: CreateReportSkills :exec
INSERT INTO report_skills (
  report_id, skills
) VALUES (
  $1,
  $2
)
`

type CreateReportSkillsParams struct {
	ReportID pgtype.UUID
	Skills   []byte
}

func (q *Queries) CreateReportSkills(ctx context.Context, arg CreateReportSkillsParams) error {
	_, err := q.db.Exec(ctx, createReportSkills, arg.ReportID, arg.Skills)
	return err
}

const createReportWork = `-- name: CreateReportWork :exec
INSERT INTO report_works (
  report_id,
  position,
  grade,
  growth_message,
  tasks_message
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
`

type CreateReportWorkParams struct {
	ReportID      pgtype.UUID
	Position      string
	Grade         string
	GrowthMessage string
	TasksMessage  string
}

func (q *Queries) CreateReportWork(ctx context.Context, arg CreateReportWorkParams) error {
	_, err := q.db.Exec(ctx, createReportWork,
		arg.ReportID,
		arg.Position,
		arg.Grade,
		arg.GrowthMessage,
		arg.TasksMessage,
	)
	return err
}

const getReport = `-- name: GetReport :one
SELECT
  reports.id,
  report_persons.name,
  report_persons.surname,
  report_persons.patronymic,
  report_persons.email,
  report_persons.telegram,
  report_works.position,
  report_works.grade,
  report_works.growth_message,
  report_works.tasks_message,
  report_skills.skills
FROM reports
LEFT JOIN report_skills ON reports.id = report_skills.report_id
LEFT JOIN report_works ON reports.id = report_works.report_id
LEFT JOIN report_persons ON reports.id = report_persons.report_id
WHERE reports.id = $1
LIMIT 1
`

type GetReportRow struct {
	ID            pgtype.UUID
	Name          pgtype.Text
	Surname       pgtype.Text
	Patronymic    pgtype.Text
	Email         pgtype.Text
	Telegram      pgtype.Text
	Position      pgtype.Text
	Grade         pgtype.Text
	GrowthMessage pgtype.Text
	TasksMessage  pgtype.Text
	Skills        []byte
}

func (q *Queries) GetReport(ctx context.Context, id pgtype.UUID) (GetReportRow, error) {
	row := q.db.QueryRow(ctx, getReport, id)
	var i GetReportRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Surname,
		&i.Patronymic,
		&i.Email,
		&i.Telegram,
		&i.Position,
		&i.Grade,
		&i.GrowthMessage,
		&i.TasksMessage,
		&i.Skills,
	)
	return i, err
}
